T·ª± h·ªçc Khoa h·ªçc M√°y T√≠nh
===============================

L∆∞u √Ω: trang h∆∞·ªõng d·∫´n n√†y ƒë√£c c√≥ nh·ªØng thay ƒë·ªïi l·ªõn v√†o th√°ng 5/2020. ƒê·ªÉ xem phi√™n b·∫£n tr∆∞·ªõc, [click v√†o ƒë√¢y](https://teachyourselfcs.com/2016/).

N·∫øu b·∫°n l√† m·ªôt k·ªπ s∆∞ t·ª± h·ªçc ho·∫∑c t·ªët nghi·ªáp t·ª´ bootcamp, b·∫°n n·ª£ ch√≠nh b·∫£n th√¢n m√¨nh vi·ªác h·ªçc khoa h·ªçc m√°y t√≠nh (KHMT). R·∫•t may, b·∫°n c√≥ th·ªÉ tham gia m·ªôt ch∆∞∆°ng tr√¨nh gi√°o d·ª•c KHMT ƒë·∫≥ng c·∫•p th·∫ø gi·ªõi m√† kh√¥ng c·∫ßn ƒë·∫ßu t∆∞ nhi·ªÅu nƒÉm v√† hay m·ªôt l∆∞·ª£ng ti·ªÅn t∆∞∆°ng ƒë·ªëi ƒë·ªÉ c√≥ m·ªôt t·∫•m b·∫±ng üí∏.

C√≥ t∆∞∆°ng ƒë·ªëi nhi·ªÅu ngu·ªìn t√†i li·ªáu ngo√†i kia, nh∆∞ng m·ªôt s·ªë t√†i li·ªáu th√¨ t·ªët h∆°n s·ªë kh√°c. B·∫°n kh√¥ng c·∫ßn m·ªôt danh s√°ch ki·ªÉu "200 kho√° h·ªçc tr·ª±c tuy·∫øn mi·ªÖn ph√≠". B·∫°n c·∫ßn c√°c c√¢u tr·∫£ l·ªùi nh∆∞ng c√¢u h·ªèi sau:

- B·∫°n n√™n h·ªçc **nh·ªØng ch·ªß ƒë·ªÅ** n√†o, v√† t·∫°i sao?
- **Cu·ªën s√°ch hay video b√†i gi·∫£ng** hay nh·∫•t cho t·ª´ng ch·ªß ƒë·ªÅ l√† g√¨?

Trang h∆∞·ªõng d·∫´n n√†y l√† n·ªó l·ª±c c·ªßa ch√∫ng t√¥i ƒë·ªÉ tr·∫£ l·ªùi d·ª©t ƒëi·ªÉm nh·ªØng c√¢u h·ªèi n√†y.

T√≥m t·∫Øt
------

H·ªçc t·∫•t c·∫£ ch√≠n ch·ªß ƒë·ªÅ d∆∞·ªõi ƒë√¢y, t·ªët nh·∫•t l√† theo th·ª© t·ª± nh∆∞ ƒë√£ tr√¨nh b√†y, s·ª≠ d·ª•ng lo·∫°t b√†i gi·∫£ng video ho·∫∑c s√°ch gi√°o tr√¨nh ƒë∆∞·ª£c g·ª£i √Ω, nh∆∞ng l√Ω t∆∞·ªüng nh·∫•t l√† h·ªçc c·∫£ hai. H√£y ƒë·∫∑t m·ª•c ti√™u cho 100-200 gi·ªù nghi√™n c·ª©u cho m·ªói ch·ªß ƒë·ªÅ, sau ƒë√≥ xem l·∫°i c√°c ch·ªß ƒë·ªÅ y√™u th√≠ch trong su·ªët s·ª± nghi·ªáp c·ªßa b·∫°n üöÄ.

|Ch·ªß ƒë·ªÅ|T·∫°i sao h·ªçc?|S√°ch|Video|
|:------|:---------|:---|:-----|
| **[L·∫≠p tr√¨nh](https://teachyourselfcs.com/#programming)**| ƒê·ª´ng l√† ng∆∞·ªùi ‚Äúch∆∞a bao gi·ªù hi·ªÉu r√µ‚Äù v·ªÅ m·ªôt th·ª© nh∆∞ ƒë·ªá quy.|*C·∫•u tr√∫c v√† di·ªÖn gi·∫£i c√°c ch∆∞∆°ng tr√¨nh m√°y t√≠nh*|Brian Harvey's Berkeley CS 61A|
|**[Ki·∫øn tr√∫c m√°y t√≠nh](https://teachyourselfcs.com/#architecture)**|N·∫øu b·∫°n kh√¥ng c√≥ n·ªÅn t·∫≥ng v·ªØng ch·∫Øc v·ªÅ c√°ch m√°y t√≠nh th·ª±c s·ª± ho·∫°t ƒë·ªông, t·∫•t c·∫£ c√°c b·∫£n abstraction cao h∆°n c·ªßa b·∫°n s·∫Ω tr·ªü n√™n kh√¥ng m·∫°ch l·∫°c.|*H·ªá th·ªëng m√°y t√≠nh: G√≥c nh√¨n c·ªßa m·ªôt l·∫≠p tr√¨nh vi√™n*|Berkeley CS 61C|
|**[Thu·∫≠t to√°n v√† c·∫•u tr√∫c d·ªØ li·ªáu](https://teachyourselfcs.com/#algorithm)**| N·∫øu b·∫°n kh√¥ng bi·∫øt c√°ch s·ª≠ d·ª•ng c·∫•u tr√∫c d·ªØ li·ªáu ph·ªï bi·∫øn nh∆∞ ngƒÉn x·∫øp, h√†ng ƒë·ª£i, c√¢y, v√† ƒë·ªì th·ªã, b·∫°n s·∫Ω kh√¥ng c√≥ th·ªÉ gi·∫£i quy·∫øt c√°c v·∫•n ƒë·ªÅ kh√≥.|*H∆∞·ªõng d·∫´n Thi·∫øt k·∫ø Thu·∫≠t to√°n*|B√†i gi·∫£ng c·ªßa Steven Skiena|
|**[To√°n cho KHMT](https://teachyourselfcs.com/#math)**| KHMT v·ªÅ c∆° b·∫£n l√† m·ªôt nh√°nh c·ªßa to√°n h·ªçc ·ª©ng d·ª•ng, v√¨ v·∫≠y h·ªçc to√°n s·∫Ω mang l·∫°i cho b·∫°n l·ª£i th·∫ø c·∫°nh tranh.|*To√°n h·ªçc cho Khoa h·ªçc M√°y t√≠nh*|MIT 6.042J c·ªßa Tom Leighton|
|**[H·ªá ƒëi·ªÅu h√†nh](https://teachyourselfcs.com/#operating-systems)**| H·∫ßu h·∫øt c√°c ƒëo·∫°n m√£ b·∫°n vi·∫øt ƒë∆∞·ª£c ch·∫°y b·ªüi m·ªôt h·ªá ƒëi·ªÅu h√†nh, v√¨ v·∫≠y b·∫°n n√™n bi·∫øt ch√∫ng t∆∞∆°ng t√°c nh∆∞ th·∫ø n√†o.|*H·ªá ƒëi·ªÅu h√†nh: Ba m·∫£nh d·ªÖ d√†ng*|Berkeley CS 162|
|**[M·∫°ng m√°y t√≠nh](https://teachyourselfcs.com/#networking)**|Internet l√† m·ªôt v·∫•n ƒë·ªÅ l·ªõn: b·∫°n c·∫ßn hi·ªÉu c√°ch n√≥ ho·∫°t ƒë·ªông ƒë·ªÉ khai th√°c h·∫øt ti·ªÅm nƒÉng c·ªßa n√≥.|*M·∫°ng m√°y t√≠nh: m·ªôt c√°ch ti·∫øp c·∫≠n t·ª´ t·∫ßng tr√™n xu·ªëng d∆∞·ªõi*|Stanford CS 144|
|**[C∆° s·ªü d·ªØ li·ªáu](https://teachyourselfcs.com/#databases)**|D·ªØ li·ªáu l√† tr·ªçng t√¢m c·ªßa h·∫ßu h·∫øt c√°c ch∆∞∆°ng tr√¨nh quan tr·ªçng, nh∆∞ng √≠t ng∆∞·ªùi hi·ªÉu c√°ch h·ªá th·ªëng c∆° s·ªü d·ªØ li·ªáu th·ª±c s·ª± ho·∫°t ƒë·ªông.|*ƒê·ªçc trong H·ªá th·ªëng C∆° s·ªü D·ªØ li·ªáu*|Joe Hellerstein's Berkeley CS 186|
|**[Ng√¥n ng·ªØ v√† Tr√¨nh bi√™n d·ªãch](https://teachyourselfcs.com/#languages)**|N·∫øu b·∫°n hi·ªÉu c√°ch ng√¥n ng·ªØ v√† tr√¨nh bi√™n d·ªãch th·ª±c s·ª± ho·∫°t ƒë·ªông, b·∫°n s·∫Ω vi·∫øt m√£ t·ªët h∆°n v√† h·ªçc ng√¥n ng·ªØ m·ªõi d·ªÖ d√†ng h∆°n.|*T·∫°o th√¥ng d·ªãch vi√™n*|Kh√≥a h·ªçc c·ªßa Alex Aiken tr√™n edX|
|**[H·ªá th·ªëng ph√¢n t√°n](https://teachyourselfcs.com/#distributed-systems)**|Ng√†y nay, *h·∫ßu h·∫øt* h·ªá th·ªëng l√† ph√¢n t√°n.|*Thi·∫øt k·∫ø c√°c ·ª©ng d·ª•ng t·∫≠p trung v·ªÅ d·ªØ li·ªáu* c·ªßa Martin Kleppmann|MIT 6.824|

V·∫´n c√≤n qu√° nhi·ªÅu?
---------------

N·∫øu √Ω t∆∞·ªüng t·ª± h·ªçc 9 ch·ªß ƒë·ªÅ trong nhi·ªÅu nƒÉm l√†m b·∫°n c·∫£m th·∫•y qu√° s·ª©c, ch√∫ng t√¥i khuy√™n b·∫°n ch·ªâ n√™n t·∫≠p trung v√†o hai cu·ªën s√°ch: *H·ªá th·ªëng m√°y t√≠nh: Quan ƒëi·ªÉm c·ªßa m·ªôt l·∫≠p tr√¨nh vi√™n* v√† *Thi·∫øt k·∫ø c√°c ·ª©ng d·ª•ng t·∫≠p trung v·ªÅ d·ªØ li·ªáu*. Theo kinh nghi·ªám c·ªßa ch√∫ng t√¥i, hai cu·ªën s√°ch n√†y mang l·∫°i hi·ªáu qu·∫£ c·ª±c k·ª≥ cao tr√™n t·ªïng th·ªùi gian ƒë·∫ßu t∆∞ h·ªçc, ƒë·∫∑c bi·ªát cho c√°c k·ªπ s∆∞ t·ª± h·ªçc v√† t·ªët nghi·ªáp t·ª´ bootcamp l√†m vi·ªác tr√™n c√°c ·ª©ng d·ª•ng tr·ª±c tuy·∫øn. Ch√∫ng c≈©ng c√≥ th·ªÉ ƒë∆∞·ª£c coi l√† ch·∫•t x√∫c t√°c gi√∫p b·∫°n c√≥ ƒë·ªông l·ª±c h·ªçc c√°c ch·ªß ƒë·ªÅ c√≤n l·∫°i.

T·∫°i sao ph·∫£i h·ªçc khoa h·ªçc m√°y t√≠nh?
---------------------------

C√≥ 2 lo·∫°i k·ªπ s∆∞ ph·∫ßn m·ªÅm: 

- nh·ªØng ng∆∞·ªùi hi·ªÉu r√µ v·ªÅ khoa h·ªçc m√°y t√≠nh ƒë·ªÉ l√†m nh·ªØng c√¥ng vi·ªác ƒë·∫ßy th·ª≠ th√°ch v√† s√°ng t·∫°o. 
- nh·ªØng ng∆∞·ªùi ch·ªâ l√†m vi·ªác ƒë·ªÅu ƒë·ªÅu v√¨ h·ªç ƒë√£ quen thu·ªôc v·ªõi m·ªôt s·ªë c√¥ng c·ª•.

C·∫£ hai ƒë·ªÅu t·ª± g·ªçi m√¨nh l√† k·ªπ s∆∞ ph·∫ßn m·ªÅm v√† c·∫£ hai ƒë·ªÅu c√≥ xu h∆∞·ªõng ki·∫øm ƒë∆∞·ª£c m·ª©c l∆∞∆°ng t∆∞∆°ng t·ª± khi m·ªõi v√†o ngh·ªÅ. Nh∆∞ng c√°c k·ªπ s∆∞ lo·∫°i 1 s·∫Ω ti·∫øn t·ªõi c√¥ng vi·ªác ho√†n thi·ªán h∆°n v√† ƒë∆∞·ª£c tr·∫£ l∆∞∆°ng cao, x·ª©ng ƒë√°ng h∆°n theo th·ªùi gian, cho d√π ƒë√≥ l√† c√°c d·ª± √°n th∆∞∆°ng m·∫°i hay c√°c d·ª± √°n ngu·ªìn m·ªü, ng∆∞·ªùi qu·∫£n l√Ω v·ªÅ k·ªπ thu·∫≠t hay b·∫£n th√¢n l√† c√° nh√¢n xu·∫•t s·∫Øc.

C√°c k·ªπ s∆∞ lo·∫°i 1 t√¨m c√°ch h·ªçc chuy√™n s√¢u v·ªÅ KHMT, cho d√π th√¥ng qua c√°c ki·ªÉu h·ªçc truy·ªÅn th·ªëng hay b·∫±ng c√°ch h·ªçc h·ªèi kh√¥ng ng·ª´ng ngh·ªâ trong su·ªët s·ª± nghi·ªáp c·ªßa h·ªç. C√°c k·ªπ s∆∞ lo·∫°i 2 th∆∞·ªùng ch·ªâ ·ªü tr√™n b·ªÅ m·∫∑t, h·ªçc c√°c c√¥ng c·ª• v√† c√¥ng ngh·ªá c·ª• th·ªÉ h∆°n l√† n·ªÅn t·∫£ng c∆° b·∫£n t·∫°o ra ch√∫ng, ch·ªâ h·ªçc c√°c k·ªπ nƒÉng m·ªõi khi c√°c c√¥ng ngh·ªá m·ªõi di·ªÖn ra v√† xu·∫•t hi·ªán.

Hi·ªán t·∫°i, s·ªë l∆∞·ª£ng ng∆∞·ªùi v√†o ng√†nh IT ƒëang tƒÉng l√™n nhanh ch√≥ng, trong khi s·ªë l∆∞·ª£ng ng∆∞·ªùi t·ªët nghi·ªáp KHMT th√¨  t∆∞∆°ng ƒë·ªëi ·ªïn ƒë·ªãnh. T√¨nh tr·∫°ng d∆∞ cung c·ªßa c√° k·ªπ s∆∞ lo·∫°i 2 n√†y ƒëang b·∫Øt ƒë·∫ßu l√†m gi·∫£m c∆° h·ªôi vi·ªác l√†m c·ªßa ch√≠nh h·ªç, v√† ƒë·∫©y h·ªç ra kh·ªèi ng√†nh IT. Cho d√π b·∫°n ƒëang ph·∫•n ƒë·∫•u ƒë·ªÉ tr·ªü th√†nh k·ªπ s∆∞ lo·∫°i 1 hay ch·ªâ ƒë∆°n gi·∫£n l√† t√¨m ki·∫øm c√¥ng vi·ªác an to√†n h∆°n, h·ªçc KHMT l√† con ƒë∆∞·ªùng ƒë√∫ng ƒë·∫Øn duy nh·∫•t.

[![@todo](./Teach%20Yourself%20Computer%20Science_files/bilotta-tweet.png)](https://twitter.com/jenna/status/838161631662092289)

H∆∞·ªõng d·∫´n chi ti·∫øt cho c√°c ch·ªß ƒë·ªÅ
--------------

### L·∫≠p tr√¨nh

H·∫ßu h·∫øt c√°c ch∆∞∆°ng tr√¨nh ƒë·∫°i h·ªçc cho ng√†nh KHMT ƒë·ªÅu b·∫Øt ƒë·∫ßu v·ªõi ph·∫ßn ‚Äúgi·ªõi thi·ªáu‚Äù v·ªÅ l·∫≠p tr√¨nh m√°y t√≠nh. C√°c kh√≥a h·ªçc t·ªët nh·∫•t cho ch·ªß ƒë·ªÅ n√†y kh√¥ng ch·ªâ gi√∫p cho ng∆∞·ªùi m·ªõi h·ªçc, m√† c√≤n r·∫•t t·ªët chho nh·ªØng ng∆∞·ªùi ƒë√£ b·ªè l·ª° c√°c kh√°i ni·ªám v√† m√¥ h√¨nh l·∫≠p tr√¨nh khi h·ªç m·ªõi h·ªçc vi·∫øt m√£.

G·ª£i √Ω chung nh·∫•t c·ªßa ch√∫ng t√¥i cho n·ªôi dung n√†y l√† cu·ªën s√°ch kinh ƒëi·ªÉn *C·∫•u tr√∫c v√† di·ªÖn gi·∫£i c√°c ch∆∞∆°ng tr√¨nh m√°y t√≠nh* (SICP - vi·∫øt t·∫Øt t√™n ti·∫øng Anh). N√≥ ƒë∆∞·ª£c cung c·∫•p tr·ª±c tuy·∫øn mi·ªÖn ph√≠ d∆∞·ªõi d·∫°ng [s√°ch ƒëi·ªán t·ª≠](https://mitpress.mit.edu/sites/default/files/sicp/full-text/book/book.html), v√† d∆∞·ªõi d·∫°ng m·ªôt t·∫≠p h·ª£p [c√°c b√†i gi·∫£ng video c·ªßa MIT](http://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-001-structure-and-interpretation-of-computer-programs-spring-2005/video-lectures/). M·∫∑c d√π nh·ªØng b√†i gi·∫£ng ƒë√≥ r·∫•t hay, nh∆∞ng ƒë·ªÅ xu·∫•t video c·ªßa ch√∫ng t√¥i l√† [b√†i gi·∫£ng SICP c·ªßa Brian Harvey](https://archive.org/details/ucberkeley-webcast-PL3E89002AA9B9879E?sort=titleSorter) (cho kh√≥a h·ªçc 61A t·∫°i Berkeley). C√°c b√†i gi·∫£ng n√†y ƒë∆∞·ª£c trau chu·ªët h∆°n v√† h∆∞·ªõng ƒë·∫øn ƒë·ªëi t∆∞·ª£ng l√† sinh vi√™n m·ªõi t·ªët h∆°n so v·ªõi c√°c b√†i gi·∫£ng c·ªßa MIT.

Ch√∫ng t√¥i khuy√™n b·∫°n n√™n h·ªçc qua √≠t nh·∫•t ba ch∆∞∆°ng ƒë·∫ßu ti√™n c·ªßa SICP v√† l√†m c√°c b√†i t·∫≠p. ƒê·ªÉ th·ª±c h√†nh th√™m, h√£y th·ª≠ gi·∫£i quy·∫øt m·ªôt lo·∫°t c√°c b√†i t·∫≠p v·ªÅ l·∫≠p tr√¨nh nh·ªè tr√™n [exercism.io](http://exercism.io/).

K·ªÉ t·ª´ khi h∆∞·ªõng d·∫´n n√†y ƒë∆∞·ª£c ƒëƒÉng l·∫ßn ƒë·∫ßu ti√™n v√†o nƒÉm 2016, m·ªôt trong nh·ªØng c√¢u h·ªèi th∆∞·ªùng g·∫∑p nh·∫•t l√† li·ªáu b√¢y gi·ªù ch√∫ng t√¥i c√≥ n√™n ƒë·ªÅ xu·∫•t c√°c video m·ªõi h∆°n c·ªßa kho√° h·ªçc 61A do John DeNero d·∫°y, v√†/ho·∫∑c cu·ªën s√°ch t∆∞∆°ng t·ª± *[So·∫°n th·∫£o ch∆∞∆°ng tr√¨nh](https://composingprograms.com/)*, v·∫´n l√† cu·ªën s√°ch SICP nh∆∞ng s·ª≠ d·ª•ng Python. Ch√∫ng t√¥i nghƒ© r·∫±ng c√°c t√†i li·ªáu c·ªßa DeNero r·∫•t tuy·ªát v√† m·ªôt s·ªë sinh vi√™n c√≥ th·ªÉ th√≠ch ch√∫ng h∆°n, nh∆∞ng ch√∫ng t√¥i v·∫´n ƒë·ªÅ xu·∫•t cu·ªë s√°ch g·ªëc c·ªßa SICP, Scheme, v√† c√°c b√†i gi·∫£ng c·ªßa Brian Harvey nh∆∞ l√† ngu·ªìn t√†i nguy√™n ƒë·∫ßu ti√™n n√™n th·ª≠.

T·∫°i sao? B·ªüi v√¨ SICP ƒë·∫∑c bi·ªát, √≠t nh·∫•t l√† nhi·ªÅu kh·∫£ nƒÉng, trong vi·ªác thay ƒë·ªïi suy nghƒ© c∆° b·∫£n c·ªßa b·∫°n v·ªÅ m√°y t√≠nh v√† l·∫≠p tr√¨nh. Kh√¥ng ph·∫£i ai c≈©ng s·∫Ω c·∫£m nh·∫≠n ƒë∆∞·ª£c ƒëi·ªÅu n√†y. M·ªôt s·ªë s·∫Ω gh√©t cu·ªën s√°ch, nh·ªØng ng∆∞·ªùi kh√°c s·∫Ω kh√¥ng v∆∞·ª£t qua ƒë∆∞·ª£c v√†i trang ƒë·∫ßu ti√™n. Nh∆∞ng gi√° tr·ªã ti·ªÅm nƒÉng m√† n√≥ mang l·∫°i r·∫•t ƒë√°ng ƒë·ªÉ th·ª≠.

N·∫øu b·∫°n kh√¥ng c·∫£m th·∫•y th√≠ch SICP, h√£y th·ª≠ *[So·∫°n th·∫£o ch∆∞∆°ng tr√¨nh](https://composingprograms.com/)*. N·∫øu v·∫´n kh√¥ng ph√π h·ª£p, h√£y th·ª≠ *[C√°ch thi·∫øt k·∫ø c√°c ch∆∞∆°ng tr√¨nh](http://www.htdp.org/)*. N·∫øu kh√¥ng c√≥ t√†i li·ªáu n√†o trong s·ªë n√†y l√†m b·∫°n c·∫£m th·∫•y b·∫°n c√≥ th·ªÉ d√†nh c√¥ng s·ª©c cho n√≥, c√≥ l·∫Ω ƒë√≥ l√† m·ªôt d·∫•u hi·ªáu cho th·∫•y b·∫°n n√™n t·∫≠p trung v√†o c√°c ch·ªß ƒë·ªÅ kh√°c trong m·ªôt th·ªùi gian v√† xem l·∫°i ch·ªß ƒë·ªÅ l·∫≠p tr√¨nh n√†y trong m·ªôt ho·∫∑c hai nƒÉm n·ªØa.

Cu·ªëi c√πng, m·ªôt ƒëi·ªÉm c·∫ßn l√†m r√µ: h∆∞·ªõng d·∫´n n√†y KH√îNG ƒë∆∞·ª£c thi·∫øt k·∫ø cho nh·ªØng ng∆∞·ªùi ho√†n to√†n m·ªõi h·ªçc l·∫≠p tr√¨nh. Ch√∫ng t√¥i gi·∫£ ƒë·ªãnh r·∫±ng b·∫°n l√† m·ªôt l·∫≠p tr√¨nh vi√™n c√≥ nƒÉng l·ª±c m√† kh√¥ng c√≥ n·ªÅn t·∫£ng v·ªÅ KHMT, ƒëang t√¨m c√°ch l·∫•p ƒë·∫ßy m·ªôt s·ªë l·ªó h·ªïng ki·∫øn ‚Äã‚Äãth·ª©c. Th·ª±c t·∫ø l√† ch√∫ng t√¥i ƒë·∫∑t ra m·ªôt ch·ªß ƒë·ªÅ v·ªÅ "l·∫≠p tr√¨nh" ch·ªâ ƒë∆°n gi·∫£n l√† m·ªôt l·ªùi nh·∫Øc nh·ªü r·∫±ng b·∫°n c√≥ th·ªÉ c·∫ßn t√¨m hi·ªÉu nhi·ªÅu h∆°n n·ªØa. ƒê·ªëi v·ªõi nh·ªØng ng∆∞·ªùi ch∆∞a bao gi·ªù vi·∫øt m√£ tr∆∞·ªõc ƒë√¢y, nh∆∞ng n·∫øu mu·ªën, b·∫°n c√≥ th·ªÉ th√≠ch m·ªôt h∆∞·ªõng d·∫´n nh∆∞ [c√°i n√†y](https://www.reddit.com/r/learnprogramming/wiki/faq#wiki_getting_started).


[![@todo Structure and Interpretation of Computer Programs](./Teach%20Yourself%20Computer%20Science_files/sicp.jpg)](https://mitpress.mit.edu/sites/default/files/sicp/full-text/book/book.html)

### Ki·∫øn tr√∫c m√°y t√≠nh

Ki·∫øn tr√∫c M√°y t√≠nh ‚Äî ƒë√¥i khi ƒë∆∞·ª£c g·ªçi l√† ‚Äúh·ªá th·ªëng m√°y t√≠nh‚Äù ho·∫∑c ‚Äút·ªï ch·ª©c c·ªßa m√°y t√≠nh‚Äù ‚Äî l√† m·ªôt g√≥c nh√¨n quan tr·ªçng ƒë·∫ßu ti√™n v·ªÅ ph·∫ßn t√≠nh to√°n b√™n d∆∞·ªõi b·ªÅ m·∫∑t c·ªßa ph·∫ßn m·ªÅm. Theo kinh nghi·ªám c·ªßa ch√∫ng t√¥i, ƒë√≥ l√† lƒ©nh v·ª±c b·ªã b·ªè qua nh·∫•t trong c√°c k·ªπ s∆∞ ph·∫ßn m·ªÅm t·ª± h·ªçc.

Cu·ªën s√°ch y√™u th√≠ch ƒë·ªÉ gi·ªõi thi·ªáu c·ªßa ch√∫ng t√¥i l√† *[H·ªá th·ªëng m√°y t√≠nh: G√≥c nh√¨n c·ªßa m·ªôt l·∫≠p tr√¨nh vi√™n (CS:APP - t√™n vi·∫øt t·∫Øt ti·∫øng Anh)](http://csapp.cs.cmu.edu/3e/home.html)* v√† kh√≥a h·ªçc ƒëi·ªÉn h√¨nh s·ª≠ d·ª•ng cu·ªën s√°ch n√†y [s·∫Ω bao g·ªìm](http://csapp.cs.cmu.edu/3e/courses.html) h·∫ßu h·∫øt c√°c ch∆∞∆°ng 1-6.

Ch√∫ng t√¥i th√≠ch cu·ªën s√°ch CS:APP v√¨ c√°ch ti·∫øp c·∫≠n th·ª±c t·∫ø, h∆∞·ªõng ƒë·∫øn l·∫≠p tr√¨nh vi√™n. M·∫∑c d√π v·∫´n c√≥ nhi·ªÅu th·ª© v·ªÅ ki·∫øn ‚Äã‚Äãtr√∫c m√°y t√≠nh trong h∆°n nh·ªØng g√¨ ƒë∆∞·ª£c ƒë·ªÅ c·∫≠p trong cu·ªën s√°ch, nh∆∞ng n√≥ l√† m·ªôt ƒëi·ªÉm kh·ªüi ƒë·∫ßu tuy·ªát v·ªùi cho nh·ªØng ai mu·ªën hi·ªÉu v·ªÅ h·ªá th·ªëng m√°y t√≠nh nh·∫±m ƒë·ªÉ vi·∫øt ra c√°c *ph·∫ßn m·ªÅm* nhanh h∆°n, hi·ªáu qu·∫£ h∆°n, v√† ƒë√°ng tin c·∫≠y h∆°n.

ƒê·ªëi v·ªõi nh·ªØng ng∆∞·ªùi mu·ªën c√≥ ph·∫ßn gi·ªõi thi·ªáu nh·∫π nh√†ng h∆°n v·ªÅ ch·ªß ƒë·ªÅ n√†y v√† s·ª± c√¢n b·∫±ng gi·ªØa ph·∫ßn c·ª©ng v√† ph·∫ßn m·ªÅm, ch√∫ng t√¥i ƒë·ªÅ xu·∫•t *C√°c y·∫øu t·ªë c·ªßa h·ªá th·ªëng m√°y t√≠nh*, c√≤n ƒë∆∞·ª£c g·ªçi l√† ‚ÄúNand2Tetris‚Äù. ƒê√¢y l√† m·ªôt cu·ªën s√°ch ƒë·∫ßy tham v·ªçng nh·∫±m cung c·∫•p cho b·∫°n s·ª± hi·ªÉu bi·∫øt ƒë·∫ßy ƒë·ªß v·ªÅ c√°ch m·ªçi th·ª© trong m√°y t√≠nh ho·∫°t ƒë·ªông. M·ªói ch∆∞∆°ng li√™n quan ƒë·∫øn vi·ªác x√¢y d·ª±ng m·ªôt ph·∫ßn nh·ªè c·ªßa h·ªá th·ªëng t·ªïng th·ªÉ, t·ª´ vi·ªác vi·∫øt c√°c c·ªïng logic c∆° b·∫£n trong HDL, th√¥ng qua CPU v√† assembler, cho ƒë·∫øn m·ªôt ·ª©ng d·ª•ng c√≥ k√≠ch th∆∞·ªõc b·∫±ng m·ªôt tr√≤ ch∆°i Tetris.

Ch√∫ng t√¥i khuy√™n ƒë·ªçc s√°u ch∆∞∆°ng ƒë·∫ßu ti√™n c·ªßa cu·ªën s√°ch v√† ho√†n th√†nh c√°c d·ª± √°n li√™n quan. ƒêi·ªÅu n√†y s·∫Ω gi√∫p b·∫°n hi·ªÉu ƒë∆∞·ª£c m·ªëi quan h·ªá gi·ªØa ki·∫øn ‚Äã‚Äãtr√∫c c·ªßa m√°y t√≠nh v√† ph·∫ßn m·ªÅm ch·∫°y tr√™n ƒë√≥.

N·ª≠a ƒë·∫ßu c·ªßa cu·ªën s√°ch (v√† t·∫•t c·∫£ c√°c d·ª± √°n c·ªßa cu·ªën s√°ch), ƒë∆∞·ª£c cung c·∫•p mi·ªÖn ph√≠ t·ª´ [trang web Nand2Tetris](http://www.nand2tetris.org/). N√≥ c≈©ng c√≥ s·∫µn d∆∞·ªõi d·∫°ng [m·ªôt kh√≥a h·ªçc Coursera v·ªõi video ƒëi k√®m](https://www.coursera.org/learn/build-a-computer).

Khi t√¨m ki·∫øm s·ª± ƒë∆°n gi·∫£n v√† g·∫Øn k·∫øt, Nand2Tetris ƒë√°nh ƒë·ªïi v·ªõi ƒë·ªô s√¢u c·ªßa ki·∫øn th·ª©c. ƒê·∫∑c bi·ªát, hai kh√°i ni·ªám r·∫•t quan tr·ªçng trong ki·∫øn ‚Äã‚Äãtr√∫c m√°y t√≠nh hi·ªán ƒë·∫°i l√† pipelining v√† ph√¢n c·∫•p b·ªô nh·ªõ, nh∆∞ng c·∫£ hai ƒë·ªÅu h·∫ßu nh∆∞ kh√¥ng c√≥ trong s√°ch.

Khi b·∫°n c·∫£m th·∫•y tho·∫£i m√°i v·ªõi n·ªôi dung c·ªßa Nand2Tetris, ch√∫ng t√¥i khuy√™n b·∫°n n√™n quay l·∫°i CS: APP ho·∫∑c xem x√©t cu·ªën s√°ch kinh ƒëi·ªÉn v√† xu·∫•t s·∫Øc *[T·ªï ch·ª©c m√°y t√≠nh v√† thi·∫øt k·∫ø](https://smile.amazon.com/Computer-Organization-Design-Fifth-Architecture/dp/0124077269)* c·ªßa Patterson v√† Hennessy. Kh√¥ng ph·∫£i m·ªçi ph·∫ßn trong s√°ch ƒë·ªÅu c·∫ßn thi·∫øt; ch√∫ng t√¥i khuy√™n b·∫°n n√™n theo d√µi[kh√≥a h·ªçc CS61C c·ªßa Berkeley](http://inst.eecs.berkeley.edu/~cs61c/sp15/) ‚ÄúNh·ªØng √Ω t∆∞·ªüng tuy·ªát v·ªùi trong ki·∫øn ‚Äã‚Äãtr√∫c m√°y t√≠nh‚Äù ƒë·ªÉ c√≥ th·ªÉ ƒë·ªçc c·ª• th·ªÉ. C√°c ghi ch√∫ b√†i gi·∫£ng v√† ph√≤ng th·ª≠ nghi·ªám c√≥ s·∫µn tr·ª±c tuy·∫øn v√† c√°c b√†i gi·∫£ng tr∆∞·ªõc ƒë√¢y c√≥ s·∫µn tr√™n [Internet Archive](https://archive.org/details/ucberkeley-webcast-PL-XXv-cvA_iCl2-D-FS5mk0jFF6cYSJs_). 

[![@todo H·ªá th·ªëng m√°y t√≠nh: G√≥c nh√¨n c·ªßa m·ªôt l·∫≠p tr√¨nh vi√™n](./Teach%20Yourself%20Computer%20Science_files/csapp.jpg)](http://csapp.cs.cmu.edu/3e/home.html)

> Ph·∫ßn c·ª©ng l√† n·ªÅn t·∫£ng

- Mike Acton, Gi√°m ƒë·ªëc k·ªπ thu·∫≠t t·∫°i Insomniac Games
([xem cu·ªôc n√≥i chuy·ªán CppCon c·ªßa √¥ng ·∫•y](https://www.youtube.com/watch?v=rX0ItVEVjHc))

### Algorithms and Data Structures

We agree with decades of common wisdom that familiarity with common algorithms and data structures is one of the most empowering aspects of a computer science education. This is also a great place to train one‚Äôs general problem-solving abilities, which will pay off in every other area of study.

There are hundreds of books available, but our favorite is *[The Algorithm Design Manual](https://smile.amazon.com/Algorithm-Design-Manual-Steven-Skiena/dp/1848000693/)* by Steven Skiena. He clearly loves algorithmic problem solving and typically succeeds in fostering similar enthusiasm among his students and readers. In our opinion, the two more commonly suggested texts (CLRS and Sedgewick) tend to be a little too proof-heavy for those learning the material primarily to help with practical problem solving.

For those who prefer video lectures, [Skiena generously provides his online](https://www.youtube.com/watch?v=A2bFN3MyNDA&list=PLOtl7M3yp-DX32N0fVIyvn7ipWKNGmwpp). We also really like Tim Roughgarden‚Äôs course, available [on Coursera](https://www.coursera.org/specializations/algorithms) and [elsewhere](http://timroughgarden.org/videos.html). Whether you prefer Skiena‚Äôs or Roughgarden‚Äôs lecture style will be a matter of personal preference. In fact, there are dozens of good alternatives, so if you happen to find another that you like, we encourage you to stick with it!

For practice, our preferred approach is for students to solve problems on [Leetcode](https://leetcode.com/). These tend to be interesting problems with decent accompanying solutions and discussions. They also help you test progress against questions that are commonly used in technical interviews at the more competitive software companies. We suggest solving around 100 random leetcode problems as part of your studies.

Finally, we strongly recommend *[How to Solve It](https://smile.amazon.com/How-Solve-Mathematical-Princeton-Science/dp/069116407X/)* as an excellent and unique guide to general problem solving; it‚Äôs as applicable to computer science as it is to mathematics.

[![The Algorithm Design Manual](./Teach%20Yourself%20Computer%20Science_files/skiena.jpg)](https://smile.amazon.com/Algorithm-Design-Manual-Steven-Skiena/dp/1848000693/) [![How to Solve It](./Teach%20Yourself%20Computer%20Science_files/polya.jpg)](https://smile.amazon.com/How-Solve-Mathematical-Princeton-Science/dp/069116407X/)

> I have only one method that I recommend extensively‚Äîit‚Äôs called think before you write.

‚Äî Richard Hamming

### Mathematics for Computer Science

In some ways, computer science is an overgrown branch of applied mathematics. While many software engineers try‚Äîand to varying degrees succeed‚Äîat ignoring this, we encourage you to embrace it with direct study. Doing so successfully will give you an enormous competitive advantage over those who don‚Äôt.

The most relevant area of math for CS is broadly called ‚Äúdiscrete mathematics‚Äù, where ‚Äúdiscrete‚Äù is the opposite of ‚Äúcontinuous‚Äù and is loosely a collection of interesting applied math topics outside of calculus. Given the vague definition, it‚Äôs not meaningful to try to cover the entire breadth of ‚Äúdiscrete mathematics‚Äù. A more realistic goal is to build a working understanding of logic, combinatorics and probability, set theory, graph theory, and a little of the number theory informing cryptography. Linear algebra is an additional worthwhile area of study, given its importance in computer graphics and machine learning.

Our suggested starting point for discrete mathematics is the set of [lecture notes by L√°szl√≥ Lov√°sz](http://www.cs.elte.hu/~lovasz/dmbook.ps). Professor Lov√°sz did a good job of making the content approachable and intuitive, so this serves as a better starting point than more formal texts.

For a more advanced treatment, we suggest *[Mathematics for Computer Science](https://courses.csail.mit.edu/6.042/spring17/mcs.pdf)*, the book-length lecture notes for the MIT course of the same name. That course‚Äôs video lectures are also [freely available](https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-042j-mathematics-for-computer-science-fall-2010/video-lectures/), and are our recommended video lectures for discrete math.

For linear algebra, we suggest starting with the [Essence of linear algebra](https://www.youtube.com/playlist?list=PLZHQObOWTQDPD3MizzM2xVFitgF8hE_ab) video series, followed by Gilbert Strang‚Äôs [book](https://www.amazon.com/Introduction-Linear-Algebra-Gilbert-Strang/dp/0980232775/) and [video lectures](https://ocw.mit.edu/courses/mathematics/18-06-linear-algebra-spring-2010/video-lectures/).

> If people do not believe that mathematics is simple, it is only because they do not realize how complicated life is.

‚Äî John von Neumann

### Operating Systems

*[Operating System Concepts](https://www.amazon.com/dp/1118063333/)* (the ‚ÄúDinosaur book‚Äù) and *[Modern Operating Systems](https://www.amazon.com/dp/013359162X/)* are the ‚Äúclassic‚Äù books on operating systems. Both have attracted criticism for their lack of clarity and general student unfriendliness.

*Operating Systems: Three Easy Pieces* is a good alternative that‚Äôs [freely available online](http://pages.cs.wisc.edu/~remzi/OSTEP/). We particularly like the structure and readability of the book, and feel that the exercises are worthwhile.

After OSTEP, we encourage you to explore the design decisions of specific operating systems, through ‚Äú{OS name} Internals‚Äù style books such as *[Lion's commentary on Unix](https://www.amazon.com/Lions-Commentary-Unix-John/dp/1573980137/)*, *[The Design and Implementation of the FreeBSD Operating System](https://www.amazon.com/Design-Implementation-FreeBSD-Operating-System/dp/0321968972/)*, and *[Mac OS X Internals](https://www.amazon.com/Mac-OS-Internals-Systems-Approach/dp/0321278542/)*. For Linux, we suggest Robert Love's fantastic [Linux Kernel Development](https://www.amazon.com/Linux-Kernel-Development-Robert-Love/dp/0672329468).

A great way to consolidate your understanding of operating systems is to read the code of a small kernel and add features. One choice is [xv6](https://pdos.csail.mit.edu/6.828/2016/xv6.html), a port of Unix V6 to ANSI C and x86, maintained for a course at MIT. OSTEP has an appendix of potential [xv6 labs](http://pages.cs.wisc.edu/~remzi/OSTEP/lab-projects-xv6.pdf) full of great ideas for potential projects.

[![Operating Systems: Three Easy Pieces](./Teach%20Yourself%20Computer%20Science_files/ostep.jpeg)](http://pages.cs.wisc.edu/~remzi/OSTEP/)

### Computer Networking

Given that so much of software engineering is on web servers and clients, one of the most immediately valuable areas of computer science is computer networking. Our self-taught students who methodically study networking find that they finally understand terms, concepts and protocols they‚Äôd been surrounded by for years.

Our favorite book on the topic is *[Computer Networking: A Top-Down Approach](https://smile.amazon.com/Computer-Networking-Top-Down-Approach-7th/dp/0133594149/)*. The small projects and exercises in the book are well worth doing, and we particularly like the ‚ÄúWireshark labs‚Äù, which they have [generously provided online](http://www-net.cs.umass.edu/wireshark-labs/).

For those who prefer video lectures, we suggest Stanford‚Äôs [*Introduction to Computer Networking course*](https://www.youtube.com/playlist?list=PLvFG2xYBrYAQCyz4Wx3NPoYJOFjvU7g2Z) previously available via Stanford's MOOC platform Lagunita, but sadly now only available as unofficial playlists on Youtube.

> You can‚Äôt gaze in the crystal ball and see the future. What the Internet is going to be in the future is what society makes it.

‚Äî Bob Kahn

[![Computer Networking: A Top-Down Approach](./Teach%20Yourself%20Computer%20Science_files/top-down.jpg)](https://smile.amazon.com/Computer-Networking-Top-Down-Approach-7th/dp/0133594149/)

### Databases

It takes more work to self-learn about database systems than it does with most other topics. It‚Äôs a relatively new (i.e. post 1970s) field of study with strong commercial incentives for ideas to stay behind closed doors. Additionally, many potentially excellent textbook authors have preferred to join or start companies instead.

Given the circumstances, we encourage self-learners to generally avoid textbooks and start with [recordings of CS 186](https://www.youtube.com/user/CS186Berkeley/videos), Joe Hellerstein‚Äôs databases course at Berkeley, and to progress to reading papers after.

One paper particularly worth mentioning for new students is ‚Äú[Architecture of a Database System](http://db.cs.berkeley.edu/papers/fntdb07-architecture.pdf)‚Äù, which uniquely provides a high-level view of how relational database management systems (RDBMS) work. This will serve as a useful skeleton for further study.

*Readings in Database Systems*, better known as [the databases ‚ÄúRed Book‚Äù](http://www.redbook.io/), is a collection of papers compiled and edited by Peter Bailis, Joe Hellerstein and Michael Stonebraker. For those who have progressed beyond the level of the CS 186 content, the Red Book should be your next stop.

If you're adamant about using an introductory textbook, we suggest *[Database Management Systems](https://smile.amazon.com/Database-Management-Systems-Raghu-Ramakrishnan/dp/0072465638/)* by Ramakrishnan and Gehrke. For more advanced students, Jim Gray‚Äôs classic *[Transaction Processing: Concepts and Techniques](https://www.amazon.com/Transaction-Processing-Concepts-Techniques-Management/dp/1558601902)* is worthwhile, but we don‚Äôt encourage using this as a first resource.

Finally, data modeling is a neglected and poorly taught aspect of working with databases. Our suggested book on the topic is *[Data and Reality: A Timeless Perspective on Perceiving and Managing Information in Our Imprecise World](https://www.amazon.com/Data-Reality-Perspective-Perceiving-Information/dp/1935504215)*.

[![Readings in Database Systems](./Teach%20Yourself%20Computer%20Science_files/redbook.jpg)](http://www.redbook.io/) [![Data and Reality](./Teach%20Yourself%20Computer%20Science_files/data-reality.jpg)](https://www.amazon.com/Data-Reality-Perspective-Perceiving-Information/dp/1935504215)

### Languages and Compilers

Most programmers learn languages, whereas most computer scientists learn *about* languages. This gives the computer scientist a distinct advantage over the programmer, even in the domain of programming! Their knowledge generalizes; they are able to understand the operation of a new language more deeply and quickly than those who have merely learned specific languages.

Our suggested introductory text is the excellent *[Crafting Interpreters](https://craftinginterpreters.com/contents.html)* by Bob Nystrom, available for free online. It's well organized, highly entertaining, and well suited to those whose primary goal is simply to better understand their languages and language tools. We suggest taking the time to work through the whole thing, attempting whichever of the "challenges" sustain your interest.

A more traditional recommendation is *[Compilers: Principles, Techniques & Tools](https://smile.amazon.com/Compilers-Principles-Techniques-Tools-2nd/dp/0321486811)*, commonly called ‚Äúthe Dragon Book‚Äù. Unfortunately, it‚Äôs not designed for self-study, but rather for instructors to pick out 1-2 semesters worth of topics for their courses.

If you elect to use the Dragon Book, it‚Äôs almost essential that you cherry-pick the topics, ideally with the help of a mentor. In fact, our suggested way to utilize the Dragon Book, if you so choose, is as a supplementary reference for a video lecture series. Our recommended one is [Alex Aiken‚Äôs, on edX](https://www.edx.org/course/compilers).

[![Compilers: Principles, Techniques & Tools](./Teach%20Yourself%20Computer%20Science_files/dragon.jpg)](https://smile.amazon.com/Compilers-Principles-Techniques-Tools-2nd/dp/0321486811)

> Don‚Äôt be a boilerplate programmer. Instead, build tools for users and other programmers. Take historical note of textile and steel industries: do you want to build machines and tools, or do you want to operate those machines?

‚Äî Ras Bodik at the start of his compilers course

### Distributed Systems

As computers have increased in number, they have also *spread*. Whereas businesses would previously purchase larger and larger mainframes, it‚Äôs typical now for even very small applications to run across multiple machines. Distributed systems is the study of how to reason about the trade-offs involved in doing so.

Our suggested book for self-study is Martin Kleppmann's *[Designing Data-Intensive Applications](https://smile.amazon.com/Designing-Data-Intensive-Applications-Reliable-Maintainable-ebook/dp/B06XPJML5D/)*. Far better than a traditional textbook, DDIA is a highly readable book designed for practitioners, which somehow avoids sacrificing depth or rigor.

For those seeking a more traditional text, or who would prefer one that‚Äôs available for free online, we suggest Maarten van Steen and Andrew Tanenbaum‚Äôs *[Distributed Systems, 3rd Edition](https://www.distributed-systems.net/index.php/books/ds3/)*.

For those who prefer video, an excellent course with videos available online is [MIT‚Äôs 6.824](https://www.youtube.com/watch?v=cQP8WApzIQQ&list=PLrw6a1wE39_tb2fErI4-WkMbsvGQk9_UB), a graduate course taught by Robert Morris with readings available [here](https://pdos.csail.mit.edu/6.824/schedule.html).

No matter the choice of textbook or other secondary resources, study of distributed systems absolutely mandates reading papers. A good list is [here](http://dsrg.pdos.csail.mit.edu/papers/), and we would highly encourage attending your local [Papers We Love](http://paperswelove.org/) chapter.

[![Designing Data-Intensive Applications](./Teach%20Yourself%20Computer%20Science_files/ddia.jpg)](https://smile.amazon.com/Designing-Data-Intensive-Applications-Reliable-Maintainable-ebook/dp/B06XPJML5D/)

Frequently asked questions
--------------------------

#### Who is the target audience for this guide?

We have in mind that you are a self-taught software engineer, bootcamp grad or precocious high school student, or a college student looking to supplement your formal education with some self-study. The question of when to embark upon this journey is an entirely personal one, but most people tend to benefit from having some professional experience before diving too deep into CS theory. For instance, we notice that students *love* learning about database systems if they have already worked with databases professionally, or about computer networking if they‚Äôve worked on a web project or two.

#### What about AI/graphics/pet-topic-X?

We‚Äôve tried to limit our list to computer science topics that we feel *every practicing software engineer* should know, irrespective of specialty or industry, but with a focus on systems. In our experience, these will be the highest ROI topics for the overwhelming majority of self-taught engineers and bootcamp grads, and provide a solid foundation for further study. Subsequently, you‚Äôll be in a much better position to pick up textbooks or papers and learn the core concepts without much guidance. Here are our suggested starting points for a couple of common ‚Äúelectives‚Äù:

-   For artificial intelligence: do [Berkeley‚Äôs intro to AI course](http://ai.berkeley.edu/) by watching the videos and completing the excellent Pacman projects. As a textbook, use Russell and Norvig‚Äôs *Artificial Intelligence: A Modern Approach*.
-   For machine learning: do Andrew Ng‚Äôs Coursera course. Be patient, and make sure you understand the fundamentals before racing off to shiny new topics like deep learning.
-   For computer graphics: work through [Berkeley‚Äôs CS 184](http://inst.eecs.berkeley.edu/~cs184/fa12/onlinelectures.html) material, and use [Computer Graphics: Principles and Practice](https://www.amazon.com/Computer-Graphics-Principles-Practice-3rd/dp/0321399528) as a textbook.

#### How strict is the suggested sequencing?

Realistically, all of these subjects have a significant amount of overlap, and refer to one another cyclically. Take for instance the relationship between discrete math and algorithms: learning math first would help you analyze and understand your algorithms in greater depth, but learning algorithms first would provide greater motivation and context for discrete math. Ideally, you‚Äôd revisit both of these topics many times throughout your career.

As such, our suggested sequencing is mostly there to help you *just get started*‚Ä¶ if you have a compelling reason to prefer a different sequence, then go for it. The most significant ‚Äúpre-requisites‚Äù in our opinion are: computer architecture before operating systems or databases, and networking and operating systems before distributed systems.

#### How does this compare to Open Source Society or freeCodeCamp curricula?

When this guide was first written in 2016, the [OSS guide](https://github.com/open-source-society/computer-science) had too many subjects, suggested inferior resources for many of them, and provided no rationale or guidance around why or what aspects of particular courses are valuable. We strove to limit our list of courses to those which you *really should know* as a software engineer, irrespective of your specialty, and to help you understand why each course is included. In the subsequent years, the OSS guide has improved, but we still think that this one provides a clearer, more cohesive path.

freeCodeCamp is focused mostly on programming, not computer science. For why you might want to learn computer science, see [above](https://teachyourselfcs.com/#why). If you are new to programming, we suggest prioritizing that, and returning to this guide in a year or two.

#### What about language X?

Learning a particular programming language is on a totally different plane to learning about an area of computer science ‚Äî learning a language is much *easier* and much *less valuable*. If you already know a couple of languages, we strongly suggest simply following our guide and fitting language acquisition in the gaps, or leaving it for afterwards. If you‚Äôve learned programming well (such as through *Structure and Interpretation of Computer Programs*), and especially if you have learned compilers, it should take you little more than a weekend to learn the essentials of a new language, after which you can learn about the libraries/tooling/ecosystem on the job.

#### What about trendy technology X?

No single technology is important enough that learning to use it should be a core part of your education. On the other hand, it‚Äôs great that you‚Äôre excited to learn about that thing. The trick is to work backwards from the particular technology to the underlying field or concept, and learn that in depth before seeing how your trendy technology fits into the bigger picture.

#### Why are you still recommending SICP?

Look, just try it. Some people find SICP mind blowing, a characteristic shared by very few other books. If you don't like it, you can always try something else and perhaps return to SICP later.

#### Why are you still recommending the Dragon book?

The Dragon book is still the most complete single resource for compilers. It gets a bad rap, typically for overemphasizing certain topics that are less fashionable to cover in detail these days, such as parsing. The thing is, the book was never intended to be studied cover to cover, only to provide enough material for an instructor to put together a course. Similarly, a self-learner can choose their own adventure through the book, or better yet follow the suggestions that lecturers of public courses have made in their course outlines.

#### How can I get textbooks cheaply?

Many of the textbooks we suggest are freely available online, thanks to the generosity of their authors. For those that aren‚Äôt, we suggest buying used copies of older editions. As a general rule, if there has been more than a couple of editions of a textbook, it‚Äôs quite likely that an older edition is perfectly adequate. It‚Äôs certainly unlikely that the newest version is 10x better than an older one, even if that‚Äôs what the price difference is!

#### Who made this?

This guide was originally written by [Oz Nova](https://twitter.com/oznova_) and [Myles Byrne](https://twitter.com/quackingduck), with 2020 updates by Oz. It is based on our experience teaching foundational computer science to over 1000 mostly self-taught engineers and bootcamp grads in small group settings in San Francisco and live online. Thank you to all of our students for your continued feedback on self-teaching resources.

We're very confident that you could teach yourself everything above, given enough time and motivation. But if you'd prefer an intensive, structured, instructor-led program, you might be interested in our [Computer Science Intensive](https://bradfieldcs.com/csi/). We [DON'T](https://ozwrites.com/masters/) suggest pursuing a master's degree.

For updates to this guide and general computer science news and resources, you may also like to join Bradfield's mailing list:

Thanks for subscribing!

[hello@bradfieldcs.com](mailto:hello@bradfieldcs.com)
 San Francisco, California
 ¬© 2016-2020 Bradfield School of Computer Science
